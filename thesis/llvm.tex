\chapter{Generisanje koda}
\label{ch:generisanje} 
\section{Uvod u LLVM}

LLVM je infrastrujtura za razvijanje optimizujućih prevodilaca. Dizajniran je tako da omogući analizu i transformaciju programa kroz sve faze programskog ciklusa: od prevođenja i povezivanja, do vremena samog izvršavanja programa\cite{llvm-cgo04}. 
Iako LLVM predstavlja akronim za ,,Low Level Virtual Machine''
\footnote{eng. virtualna mašina niskog nivoa}
, sam naziv možda ne predstavlja najjasniju sliku u to šta LLVM pruža, a gde njegov domen prestaje. 
Pojam ,,virtualna mašina'' se često vezuje za Java ili .net virtualnu mašinu koje definišu koncepte višeg nivoa kao što su klase, nasleđivanje, izuzeci ili automatsko upravljanje memorijom. 
Sve ove stvari su izvan opsega LLVM-a, koji sa druge strane može biti korišćen da se takve virtualne mašine implementiraju. 
Još jedna stvar koja se podrazumeva kod drugih virtualnih mašina je da je njihov bajt-kod portabilan između platformi. 
Sa druge strane kako bi LLVM omogućio generisanje efikasnog mašinskog koda za konkretnu procesorsku arhitekturu, on mora da omogući autorima kompajlera pristup specifičnim operacijama podržanih arhitektura. 

Neki od projekata koji se baziraju ili koriste LLVM su Clang \ndash kompajler za C, C++ i Objective C, 
zatim VMKit projekat implementacije Java virtualne mašine, 
Glasgow Haskell Compiler od skora ima opciju da preko LLVM-a generiše kod, 
Rubinius implementacija Ruby-ja koristi LLVM za optimizacije i JIT
\footnote{\skr \eng Just in Time \ndash Prevođenje međukoda u mašinski kod neposredno pre izvršavanja} 
kompajliranje.

\begin{figure}[h]

\centering
\begin{tikzpicture}
	[inner sep=2.8mm,
	box/.style={rectangle, draw, minimum width=25mm, }]
	\node[box] (c-frontend)   {C};
	\node[box] (haskell-frontend)  [below=of c-frontend]  {Haskell};
	\node[box] (other-frontend)  [below=of haskell-frontend]  {$\cdots$};
	\node[box] (optimizers)  [right=of haskell-frontend]  {Optimizacije}
		edge [<-] (c-frontend)
		edge [<-] (haskell-frontend)
		edge [<-] (other-frontend);
	\node[box] (x86-backend) [right=of optimizers] {x86}
		edge [<-] (optimizers);
	\node[box] (arm-backend) [above=of x86-backend] {ARM}
		edge [<-] (optimizers);
	\node[box] (other-backend) [below=of x86-backend] {$\cdots$}
	edge [<-] (optimizers);
\end{tikzpicture} \\

\caption{LLVM omogućava da se delovi arhitekture kompajlera kao što su optimizacije i generisanje mašinskog koda dele između nezavisnih projekata}
\end{figure}

\section{LLVM međureprezentacija}

Centralno mesto u arhitekturi LLVM-a\cite{aosa} zauzima međureprezentacija\footnote{\eng Intermediate Representation \ndash IR} 
kojom se opisuje kod unutar sistema. 
LLVM IR je dizajniran da omogući analize i transformacije koda kakve se mogu očekivati u delu kompajlera koji se bavi optimizacijom. 
Ono što je značajno kod ove reprezentacije je da ne predstavlja neki interni implementacioni detalj kao kod vecine kompajlera, 
nego je pogurana u prvi plan kao jezik jasno definisane semantike. 
LLVM međureprezentacija se tako sasvim ravnopravno može opisati svojom sintaksom sličnom asembleru, 
bajt-kodom i direktno iz programa putem C++ API-ja\footnote{\eng Application Programming Interface}.

Arhitektura virtualne mašine je load/store, odnosno jedine dve instrukcije koje barataju memorijom su \mj{load} i \mj{store}. 
Ostale instrukcije barataju samo registrima.
Većina instrukcija je u troadresnoj formi: uzimaju jedan ili dva operanda i proizvode jedan rezultat.
Autoru prevodioca je na raspolaganju beskonacan broj virtualnih registara koji mogu da drže neki od prostih tipova (boolean, broj ili pokazivač). Mapiranje iz virtualnih u stvarne registre vrši sam LLVM prilikom generisanja mašinskog koda.

Još neke značajne osobine LLVM reprezentacije su 
SSA forma\footnote{\skr \eng Static single asignement \ndash Statička jedinstvena dodela}
striktno tipiziranje podataka
pristup operacijama niskog nivoa, uključujući i instrukcije specifične za pojedine procesore.

Informacije o LLVM sintaksi, tipovima i instrukcijama potrebne za razumevanje primera i generisanog koda mogu se naći u dodatku \ref{ch:llvm}.

\subsection*{Statička jedinstvena dodela}

Virtualni registri su u SSA formi, koja predstavlja primarnu reprezentaciju koda.
To znači da se u svaki virtuelni registar može pisati samo jednom i da je svaki registar definisan pre prve upotrebe.
SSA forma se ne odnosi na memorijske lokacije.

Ovim izborom omogućeno je jednostavno kodiranje efikasnih optimizacije koje u velikoj meri zavise od toka podataka kroz telo programa kao što su propagacija konstanti ili opsega mogućih vrednosti, eliminacija mrtvog koda ili alokacija registara.


% The LLVM instruction set includes an explicit phi instruction, which corresponds directly to the standard (non-gated) φ function of SSA form.

% Non-loop transformations in SSA form are further simpliﬁed because they do not encounter anti- or output dependences on SSA registers.

% Non-memory transformations are also greatly simpliﬁed because (unrelated to SSA) registers cannot have aliases.

% LLVM also makes the Control Flow Graph (CFG) of every function explicit in the representation.

% A function is a set of basic blocks, and each basic block is a sequence of LLVM instructions, ending in exactly one terminator instruction (branches, return, unwind, or invoke).

% Each terminator explicitly speciﬁes its successor basic blocks.

\section{Optimizacija koda}

