
\appendix

\chapter{ANTRL}
\label{ch:antlr}

U najširim crtama, ANTLR koristi varijantu EBNF\footnote{\skr\eng Extended Backus-Naur Form} notacije sličnu onoj koju koristi YACC.

\section{ANTLR sintaksa}

Terminali velika slova, neterminali mala

\section{Atributi i akcije}

\section{Izlazi parsera}


\chapter{Listing gramatike}
\lstset{
  basicstyle=\footnotesize\ttfamily
}

\lstinputlisting{../src/parser/MicroJava.g}

\chapter{LLVM}
\label{ch:llvm}
Za inspekciju i razumevanje generisanog koda, korisno je poznavati osnove LLVM asemblerskog jezika koji je ovde predstavljen u tri dela: sintaksa, tipovi i pregled najkorisnijih instrukcija.


\section{LLVM sintaksa}



\section{LLVM tipovi}

Tipovi podataka u LLVM-u omogućavaju da brojne optimizacije budu spovedene direktno nad međureprezentacijom, 
bez potrebe obavljanja uporedne analize mogućih vrednosti u nekom registru pre primene transformacije.
LLVM je striktan po pitanju tipova u smislu da ni u jednom trenutku neće izvršiti implicitnu konverziju između dva tipa, 
uključujući tu i proširenje brojnih vrednosi ili pretvaranje jednog tipa pokazivača u drugi. 
Sa druge strane korisnika ništa ne sprečava da izvrši konverziju između bilo koja dva tipa odgovarajućim instrukcijama.

Tipovi se mogu podeliti na primitivne kao što su tipovi celobrojnih i realnih brojeva, labela, i metapodatak; 
i izvedene tipove kao što su nizovi, funkcije, pokazivači, strukture i vektori.

Osim ove podele bitno je istaći da nisu svi tipovi ravnopravni.
Oni tipovi koji mogu biti rezultat LLVM instrukcija i mogu se skladištiti u memoriji, prosleđivati kao parametar ili vraćati kao rezultat funkcije, nazivaju se tipovi prvog reda. Tipovi prvog reda su: celobrojni i realni tipovi, pokazivači, nizovi, strukture, vektori, labele i metapodaci.


\subsection*{Primitivni tipovi}

Primitivni tipovi su osnovni gradivni blokovi LLVM sistema.

Pošto tipovi celih i realnih brojeva zavise od podrške konkretne procesorske arhitekture,
sam LLVM pruža veliku fleksibilnost u njihovom deklarisanju
pa su mogući tipovi bilo koje širine od 1 do $2^{23} - 1$ (pribliižno 8 miliona) koji se označavaju sa \code{iN} gde \code{N} predstavlja širinu u bitima. Posebna instrukcija mapira pojedine tipove na 

Postoji 5 tipova realnih brojeva: 
\code{float} koji je širine 32 bita, 
\code{double} širine 64 bita, 
\code{fp128} od 128 bita sa mantisom od 112 bita, 
kao i hardverski specifične x86\_{}fp80 širine 80 bita 
i ppc\_{}fp128 koji takodje ima 128 bita, ali mantisu širine 64 bita.


\subsection*{Izvedeni tipovi}


% opis izvedenih tipova



\section{Korišćene LLVM instrukcije}

Sledi pregled svih potrebnih instrukcija za razumevanje generisanog MicroJava koda.

\subsection*{Memorijske instrukcije}

\begin{description}
\item[\code{alloca}] Alokacija memorije na steku. Memorija se automatski oslobađa po izlasku iz funkcije.
\item[\code{load}] Učitavanje vrednosti sa date memorijske lokacije u registar. Moguće je samo učitavanje vrednosti prvog reda.
\item[\code{store}] upisivanje u memoriju
\item[\code{gep}] Računanje vrednosti pokazivača u okviru niza ili strukture.
\end{description}

\subsection*{Aritmetičko logičke instrukcije}

\begin{description}
\item[\code{add, sub, mul, sdiv, srem, neg}] Celobrojne aritmetičke operacije. Oba operanda moraju biti istog tipa.
\item[\code{icmp}] Celobrojno poređenje datih argumenata. Prvi argument je vrsta poređenja i moze biti
jedno od: \code{eq} - jednako,  \code{ne} - različito, \code{sgt} - veće, \code{sge} - veće ili jednako,  \code{slt} - manje i  \code{sle} - manje ili jednako, 
\item[\code{and, or}] Bit-logičke operacije. Argumenti mogu biti bilo kog celobrojnog tipa, ali u slučaju MicroJava-e, uvek je u pitanju \code{i1}
\end{description}

\subsection*{Kontrola toka}

\begin{description}
\item[\code{br}] Instrukcija skoka kojom se kontrola toka prebacuje bloku unutar iste funkcije. Postoje dva oblika ove instrukcije: \textit{bezuslovni skok} koji za parametar prima labelu bloka na koji se skače i \textit{uslovni skok} koji prima vrednost tipa \code{i1} i dve labele.
\item[\code{call}] poziv funkcije
\item[\code{ret}] Vraća kontrolu toka, a opciono i povratnu vrednost pozivaocu trenutne funkcije. Da bi funkcija bila ispravna, tip vrednosti koja se vraca mora biti jednak povratnom tipu finkcije, odnosno vrednost mora biti \code{void} ako funkcija ne vraća vrednost. Povratni tip mora biti prvog reda.
\end{description}

\subsection*{Konverzije}

\begin{description}
\item[\code{bitcast}] Konvertuje datu vrednost u zadati tip bez promene bitova. Pogodno za konvertovanje tipova pokazivača ili tip pokazivača u celobrojni tip odgovarajuće širine.
\item[\code{sextorbitcast}]
\item[\code{zext}] Uzima kao parametre celobrojnu vrednost tipa \code{t1} i celobrojni tip \code{t2} veće preciznosti, proširi datu vrednost nulama sa leve strane i vrati vrednost tipa \code{t2}. Ova operacija uvek vrši konverziju, zato sto širina tipa \code{t2} mora biti strogo veća od širine tipa \code{t1}
\item[\code{trunc}] Uzima kao parametre celobrojnu vrednost tipa \code{t1} i celobrojni tip \code{t2} manje preciznosti, odbaci više bite date vrednosti i vrati vrednost tipa \code{t2}. Ova operacija uvek vrši konverziju, zato što širina tipa \code{t2} mora biti strogo manja od širine tipa \code{t1}
\end{description}



\chapter{Dokumentacija MicroJava kompajlera}

\section{Instalacija}

Projekat se može instalirati kompajliranjem iz koda. Kod je razvijan i testiran
na Linuxu, ali bi trebalo da radi i na drugim platformama.

\subsection*{Zavisnosti}

Alati potrebni za izgradnju projekta:
\begin{itemize}
\item CMake
\item Antlr3
\item Odgovarajuće platformsko razvojno okruženje (Make/GCC, VisualStudio, XCode)
\end{itemize}

Biblioteke koje treba da su dostupne na sistemu:
\begin{itemize}
\item LLVM 3.6
\item Antlr3c
\end{itemize}

Na Debian Linuxu, sve potrebne zavisnosti mogu da se instaliraju na sledeći način:

\begin{lstlisting}
# apt-get install build-essential cmake antlr3 antlr3c-dev \
          llvm-3.6 llvm-3.6-dev llvm-3.6-tools
\end{lstlisting}

\subsection*{Kompajliranje}

Ukoliko su sve zavisnosti zadovoljene, pokretanje cmake alata će da napravi
odgovarajuće projektne fajlove za trenutnu platformu.

Na Linuxu će biti generisan `Makefile`, pa kompajliranje projeka izgleda ovako:

\begin{lstlisting}
$ cmake
$ make
\end{lstlisting}

Izvršni fajlovi se nalaze u \texttt{src/mjc} diretkorijumu.

\section{Korišćenje}

Interpreter se pokreće komandom \texttt{mji} koja od argumenata prima putanju do fajla koji treba izvršiti.

Kompajler se pokreće komandom \texttt{mjc} koja osim putanje do fajla opciono prima još dva argumenta:
\begin{description}
\item[\texttt{-O}] nivo optimizacije, koji može biti vrednost 0-3 (podrazumevano 2)
\item[\texttt{-t}] tip izlaza koji može biti:

\begin{itemize}
    \item \texttt{ast} - tekstualna reprezentacija apstraktnog sintaksnog stabla
    \item \texttt{llvm} - LLVM asembler
    \item \texttt{bc} - LLVM bajt kod
    \item \texttt{asm} - platformski asembler
    \item \texttt{obj} - objektni fajl (podrazumevana vrednost)
\end{itemize}
\end{description}

Da bi se dobio izvršni fajl, objektni fajl je potrebno linkovati, na primer na sledeći način:

\begin{lstlisting}
$ gcc -o program program.o
\end{lstlisting}
